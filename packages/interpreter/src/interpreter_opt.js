export function main() { console.log("main"); let e = window.document.getElementById("main"); null != e && (window.interpreter = new Interpreter(e), window.ipc.postMessage(t("initialize"))) } export function work_last_created(e) { window.interpreter.Work(e) } class e { constructor(e) { this.global = {}, this.local = {}, this.root = e } create(e, t, s, a) { if (a) void 0 === this.global[e] ? (this.global[e] = {}, this.global[e].active = 1, this.global[e].callback = s, this.root.addEventListener(e, s)) : this.global[e].active++; else { const a = t.getAttribute("data-dioxus-id"); this.local[a] || (this.local[a] = {}), this.local[a][e] = s, t.addEventListener(e, s) } } remove(e, t, s) { if (s) this.global[t].active--, 0 === this.global[t].active && (this.root.removeEventListener(t, this.global[t].callback), delete this.global[t]); else { const s = e.getAttribute("data-dioxus-id"); delete this.local[s][t], 0 === this.local[s].length && delete this.local[s], e.removeEventListener(t, handler) } } } export class JsInterpreter { constructor(t, s, a, i, o) { this.root = t, this.lastNode = t, this.listeners = new e(t), this.handlers = {}, this.handler = () => { }, this.nodes = [t], this.parents = [], this.view = new DataView(s.buffer), this.idSize = 1, this.ptr_ptr = a, this.str_ptr_ptr = i, this.str_len_ptr = o, this.strings = "", this.strPos = 0, this.decoder = new TextDecoder, window.interpreter = this } SetEventHandler(e) { this.handler = e } Work(e) { let t, a, i, o, r, c, n, d, h, l, u, p; this.view = new DataView(e.buffer); const g = this.view; this.u8BufPos = this.view.getUint32(this.ptr_ptr, !0); const m = this.view.getUint32(this.str_ptr_ptr, !0), b = g.getUint32(this.str_len_ptr, !0), f = new DataView(e.buffer, m, b); for (this.strings = this.decoder.decode(f), this.strPos = 0; ;)switch (g.getUint8(this.u8BufPos++)) { case 0: for (t = this.getNode(), a = this.decodeU32(), l = 0; l < a; l++)t.appendChild(this.nodes[this.decodeId()]); break; case 1: for (t = this.getNode(), a = this.decodeU32(), i = [], l = 0; l < a; l++)i.push(this.nodes[this.decodeId()]); t.replaceWith(...i); break; case 2: for (t = this.getNode(), a = this.decodeU32(), i = [], l = 0; l < a; l++)i.push(this.nodes[this.decodeId()]); t.after(...i); break; case 3: for (t = this.getNode(), a = this.decodeU32(), i = [], l = 0; l < a; l++)i.push(this.nodes[this.decodeId()]); t.before(...i); break; case 4: this.getNode().remove(); break; case 5: this.lastNode = document.createTextNode(this.strings.substring(this.strPos, this.strPos += this.decodeU16())), 1 === this.view.getUint8(this.u8BufPos++) && (this.nodes[this.decodeId()] = this.lastNode), this.checkAppendParent(); break; case 6: u = this.strings.substring(this.strPos, this.strPos += this.decodeU16()), 1 === this.nodes[this.u8BufPos++] ? this.lastNode = document.createElementNS(u, this.strings.substring(this.strPos, this.strPos += this.decodeU16())) : this.lastNode = document.createElement(u), 1 === this.view.getUint8(this.u8BufPos++) && (this.nodes[this.decodeId()] = this.lastNode), this.checkAppendParent(), i = this.decodeU32(), i > 0 && this.parents.push([this.lastNode, i]); break; case 7: this.lastNode = document.createElement("pre"), this.lastNode.hidden = !0, 1 === this.view.getUint8(this.u8BufPos++) && (this.nodes[this.decodeId()] = this.lastNode), this.checkAppendParent(); break; case 8: o = this.decodeMaybeId(), c = this.strings.substring(this.strPos, this.strPos += this.decodeU16()), r = this.nodes[o], r.setAttribute("data-dioxus-id", o), this.listeners.create(c, r, this.handler, 1 == g.getUint8(this.u8BufPos++)); break; case 9: r = this.getNode(), r.removeAttribute("data-dioxus-id"), this.listeners.remove(r, this.strings.substring(this.strPos, this.strPos += this.decodeU16()), 0 == g.getUint8(this.u8BufPos++)); break; case 10: r = this.getNode(), h = this.strings.substring(this.strPos, this.strPos += this.decodeU16()), r.textContent = h; break; case 11: if (r = this.getNode(), d = this.strings.substring(this.strPos, this.strPos += this.decodeU16()), n = null, 1 == this.view.getUint8(this.u8BufPos++) && (n = this.strings.substring(this.strPos, this.strPos += this.decodeU16())), p = this.strings.substring(this.strPos, this.strPos += this.decodeU16()), "style" === n) r.style[d] = p; else if (null != n || null != n) r.setAttributeNS(n, d, p); else switch (d) { case "value": p !== r.value && (r.value = p); break; case "checked": r.checked = "true" === p; break; case "selected": r.selected = "true" === p; break; case "dangerous_inner_html": r.innerHTML = p; break; default: "false" === p && s.hasOwnProperty(d) ? r.removeAttribute(d) : r.setAttribute(d, p) }break; case 12: r = this.getNode(), d = this.strings.substring(this.strPos, this.strPos += this.decodeU16()), 1 == this.view.getUint8(this.u8BufPos++) ? r.removeAttributeNS(this.strings.substring(this.strPos, this.strPos += this.decodeU16()), d) : r.removeAttributeNS(n, d); break; case 13: this.lastNode = this.getNode().cloneNode(!0), 1 === this.view.getUint8(this.u8BufPos++) && (this.nodes[this.decodeId()] = current); break; case 14: for (let e = this.getNode().cloneNode(!0).firstChild; null !== e; e = e.nextSibling)1 === this.view.getUint8(this.u8BufPos++) && (this.nodes[this.decodeId()] = e); break; case 15: this.lastNode = this.lastNode.firstChild; break; case 16: this.lastNode = this.lastNode.nextSibling; break; case 17: this.lastNode = this.lastNode.parentNode; break; case 18: this.nodes[this.decodeId()] = this.lastNode; break; case 19: this.lastNode = this.nodes[this.decodeId()]; break; case 20: this.idSize = this.view.getUint8(this.u8BufPos++); break; case 21: return; default: return void this.u8BufPos-- } } checkAppendParent() { if (this.parents.length > 0) { const e = this.parents[this.parents.length - 1]; e[1]--, 0 === e[1] && this.parents.pop(), e[0].appendChild(this.lastNode) } } getNode() { return 1 === this.view.getUint8(this.u8BufPos++) ? this.nodes[this.decodeId()] : this.lastNode } decodeMaybeId() { return 0 === this.view.getUint8(this.u8BufPos++) ? null : this.decodeId() } decodeId() { switch (this.idSize) { case 1: return this.view.getUint8(this.u8BufPos++); case 2: return this.u8BufPos += 2, this.view.getUint16(this.u8BufPos - 2, !0); case 4: return this.u8BufPos += 4, this.view.getUint32(this.u8BufPos - 4, !0); case 8: return this.u8BufPos += 8, this.view.getUint64(this.u8BufPos - 8, !0); default: let e = this.view.getUint8(this.u8BufPos++); for (let t = 1; t < this.idSize; t++)e |= this.view.getUint8(this.u8BufPos++) << 8 * t; return e } } decodeU64() { return this.u8BufPos += 8, this.view.getUint64(this.u8BufPos - 8, !0) } decodeU32() { return this.u8BufPos += 4, this.view.getUint32(this.u8BufPos - 4, !0) } decodeU16() { return this.u8BufPos += 2, this.view.getUint16(this.u8BufPos - 2, !0) } handleEdits(e) { for (let t of e) this.handleEdit(t) } handleEdit(e) { switch (e.type) { case "PushRoot": this.PushRoot(e.root); break; case "AppendChildren": this.AppendChildren(e.root, e.children); break; case "ReplaceWith": this.ReplaceWith(e.root, e.nodes); break; case "InsertAfter": this.InsertAfter(e.root, e.nodes); break; case "InsertBefore": this.InsertBefore(e.root, e.nodes); break; case "Remove": this.Remove(e.root); break; case "CreateTextNode": this.CreateTextNode(e.text, e.root); break; case "CreateElement": this.CreateElement(e.tag, e.root, e.children); break; case "CreateElementNs": this.CreateElementNs(e.tag, e.root, e.ns, e.children); break; case "CreatePlaceholder": this.CreatePlaceholder(e.root); break; case "RemoveEventListener": this.RemoveEventListener(e.root, e.event_name); break; case "NewEventListener": let s = s => { let a = s.target; if (null != a) { let i = a.getAttribute("data-dioxus-id"), o = a.getAttribute("dioxus-prevent-default"); if ("click" === s.type) { if ("onclick" !== o && "A" === a.tagName) { s.preventDefault(); const e = a.getAttribute("href"); "" !== e && null != e && window.ipc.postMessage(t("browser_open", { href: e })) } "BUTTON" === a.tagName && "submit" == s.type && s.preventDefault() } for (; null == i;) { if (null === a.parentElement) return; a = a.parentElement, i = a.getAttribute("data-dioxus-id") } o = a.getAttribute("dioxus-prevent-default"); let r = serialize_event(s); if (o === `on${s.type}` && s.preventDefault(), "submit" === s.type && s.preventDefault(), "FORM" === a.tagName && ("submit" === s.type || "input" === s.type)) for (let e = 0; e < a.elements.length; e++) { let t = a.elements[e], s = t.getAttribute("name"); null != s && ("checkbox" === t.getAttribute("type") ? r.values[s] = t.checked ? "true" : "false" : "radio" === t.getAttribute("type") ? t.checked && (r.values[s] = t.value) : r.values[s] = t.value ?? t.textContent) } if (null === i) return; i = parseInt(i), window.ipc.postMessage(t("user_event", { event: e.event_name, mounted_dom_id: i, contents: r })) } }; this.NewEventListener(e.event_name, e.root, s, function (e) { switch (e) { case "copy": case "cut": case "paste": case "compositionend": case "compositionstart": case "compositionupdate": case "keydown": case "keypress": case "keyup": case "focusout": case "focusin": case "change": case "input": case "invalid": case "reset": case "submit": case "click": case "contextmenu": case "doubleclick": case "dblclick": case "drag": case "dragend": case "dragleave": case "dragover": case "dragstart": case "drop": case "mousedown": case "mousemove": case "mouseout": case "mouseover": case "mouseup": case "pointerdown": case "pointermove": case "pointerup": case "pointercancel": case "gotpointercapture": case "lostpointercapture": case "pointerover": case "pointerout": case "select": case "touchcancel": case "touchend": case "touchmove": case "touchstart": case "wheel": case "encrypted": case "animationstart": case "animationend": case "animationiteration": case "transitionend": case "toggle": return !0; case "focus": case "blur": case "dragenter": case "dragexit": case "mouseenter": case "mouseleave": case "scroll": case "pointerenter": case "pointerleave": case "abort": case "canplay": case "canplaythrough": case "durationchange": case "emptied": case "ended": case "error": case "loadeddata": case "loadedmetadata": case "loadstart": case "pause": case "play": case "playing": case "progress": case "ratechange": case "seeked": case "seeking": case "stalled": case "suspend": case "timeupdate": case "volumechange": case "waiting": return !1 } }(e.event_name)); break; case "SetText": this.SetText(e.root, e.text); break; case "SetAttribute": this.SetAttribute(e.root, e.field, e.value, e.ns); break; case "RemoveAttribute": this.RemoveAttribute(e.root, e.name, e.ns); break; case "CloneNode": this.CloneNode(e.id, e.new_id); break; case "CloneNodeChildren": this.CloneNodeChildren(e.id, e.new_ids); break; case "FirstChild": this.FirstChild(); break; case "NextSibling": this.NextSibling(); break; case "ParentNode": this.ParentNode(); break; case "StoreWithId": this.StoreWithId(BigInt(e.id)); break; case "SetLastNode": this.SetLastNode(BigInt(e.id)) } } } export function serialize_event(e) { switch (e.type) { case "copy": case "cut": case "past": case "focus": case "blur": case "select": case "scroll": case "abort": case "canplay": case "canplaythrough": case "durationchange": case "emptied": case "encrypted": case "ended": case "error": case "loadeddata": case "loadedmetadata": case "loadstart": case "pause": case "play": case "playing": case "progress": case "ratechange": case "seeked": case "seeking": case "stalled": case "suspend": case "timeupdate": case "volumechange": case "waiting": case "toggle": default: return {}; case "compositionend": case "compositionstart": case "compositionupdate": { let { data: t } = e; return { data: t } } case "keydown": case "keypress": case "keyup": { let { charCode: t, key: s, altKey: a, ctrlKey: i, metaKey: o, keyCode: r, shiftKey: c, location: n, repeat: d, which: h, code: l } = e; return { char_code: t, key: s, alt_key: a, ctrl_key: i, meta_key: o, key_code: r, shift_key: c, location: n, repeat: d, which: h, code: l } } case "change": { let t, s = e.target; return t = "checkbox" === s.type || "radio" === s.type ? s.checked ? "true" : "false" : s.value ?? s.textContent, { value: t, values: {} } } case "input": case "invalid": case "reset": case "submit": { let t = e.target, s = t.value ?? t.textContent; return "checkbox" === t.type && (s = t.checked ? "true" : "false"), { value: s, values: {} } } case "click": case "contextmenu": case "doubleclick": case "dblclick": case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": case "mousedown": case "mouseenter": case "mouseleave": case "mousemove": case "mouseout": case "mouseover": case "mouseup": { const { altKey: t, button: s, buttons: a, clientX: i, clientY: o, ctrlKey: r, metaKey: c, offsetX: n, offsetY: d, pageX: h, pageY: l, screenX: u, screenY: p, shiftKey: g } = e; return { alt_key: t, button: s, buttons: a, client_x: i, client_y: o, ctrl_key: r, meta_key: c, offset_x: n, offset_y: d, page_x: h, page_y: l, screen_x: u, screen_y: p, shift_key: g } } case "pointerdown": case "pointermove": case "pointerup": case "pointercancel": case "gotpointercapture": case "lostpointercapture": case "pointerenter": case "pointerleave": case "pointerover": case "pointerout": { const { altKey: t, button: s, buttons: a, clientX: i, clientY: o, ctrlKey: r, metaKey: c, pageX: n, pageY: d, screenX: h, screenY: l, shiftKey: u, pointerId: p, width: g, height: m, pressure: b, tangentialPressure: f, tiltX: v, tiltY: k, twist: y, pointerType: w, isPrimary: _ } = e; return { alt_key: t, button: s, buttons: a, client_x: i, client_y: o, ctrl_key: r, meta_key: c, page_x: n, page_y: d, screen_x: h, screen_y: l, shift_key: u, pointer_id: p, width: g, height: m, pressure: b, tangential_pressure: f, tilt_x: v, tilt_y: k, twist: y, pointer_type: w, is_primary: _ } } case "touchcancel": case "touchend": case "touchmove": case "touchstart": { const { altKey: t, ctrlKey: s, metaKey: a, shiftKey: i } = e; return { alt_key: t, ctrl_key: s, meta_key: a, shift_key: i } } case "wheel": { const { deltaX: t, deltaY: s, deltaZ: a, deltaMode: i } = e; return { delta_x: t, delta_y: s, delta_z: a, delta_mode: i } } case "animationstart": case "animationend": case "animationiteration": { const { animationName: t, elapsedTime: s, pseudoElement: a } = e; return { animation_name: t, elapsed_time: s, pseudo_element: a } } case "transitionend": { const { propertyName: t, elapsedTime: s, pseudoElement: a } = e; return { property_name: t, elapsed_time: s, pseudo_element: a } } } } function t(e, t = {}) { return JSON.stringify({ method: e, params: t }) } const s = { allowfullscreen: !0, allowpaymentrequest: !0, async: !0, autofocus: !0, autoplay: !0, checked: !0, controls: !0, default: !0, defer: !0, disabled: !0, formnovalidate: !0, hidden: !0, ismap: !0, itemscope: !0, loop: !0, multiple: !0, muted: !0, nomodule: !0, novalidate: !0, open: !0, playsinline: !0, readonly: !0, required: !0, reversed: !0, selected: !0, truespeed: !0 };